package hyphanet.base;

import org.jspecify.annotations.Nullable;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.Arrays;
import java.util.Date;
import java.util.Objects;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * This class contains static methods used for parsing boolean and unsigned long fields in
 * Hyphanet messages. Also, some general utility methods for dealing with string and numeric
 * data.
 *
 * @author oskar
 */
public final class Fields {

    private static final long[] MULTIPLES =
        {1000, 1L << 10, 1000 * 1000, 1L << 20, 1000L * 1000L * 1000L, 1L << 30,
            1000L * 1000L * 1000L * 1000L, 1L << 40, 1000L * 1000L * 1000L * 1000L * 1000,
            1L << 50, 1000L * 1000L * 1000L * 1000L * 1000L * 1000L, 1L << 60};
    private static final String[] MULTIPLES_2 =
        {"k", "K", "m", "M", "g", "G", "t", "T", "p", "P", "e", "E"};

    private Fields() {
        throw new AssertionError("Utility class should not be instantiated");
    }

    /**
     * Converts a hexadecimal string to a long value using two's complement representation.
     * Unlike {@link Long#parseLong(String, int)}, this method interprets the input as two's
     * complement, making it compatible with values generated by
     * {@link Long#toHexString(long)}.
     *
     * <p><strong>Examples:</strong><br>
     * {@code hexToLong("FF") returns 255L}<br>
     * {@code hexToLong("FFFFFFFFFFFFFFFF") returns -1L}<br>
     * {@code hexToLong("7FFFFFFFFFFFFFFF") returns Long.MAX_VALUE}
     *
     * @param hex the hexadecimal string to convert. Can contain uppercase or lowercase letters
     *            [a-fA-F] and digits [0-9]. Must not exceed 16 characters after trimming
     *            whitespace.
     *
     * @return the long value represented by the hexadecimal string
     *
     * @throws NumberFormatException if the input string is empty, exceeds 16 characters, or
     *                               contains invalid hexadecimal characters (valid:
     *                               [0-9a-fA-F])
     * @see Long#toHexString(long)
     * @see Character#digit(char, int)
     */
    public static long hexToLong(String hex) throws NumberFormatException {
        // Remove leading/trailing whitespace
        String cleanHex = hex.strip();

        if (cleanHex.isEmpty()) {
            throw new NumberFormatException("Input hex string cannot be empty");
        }

        if (cleanHex.length() > 16) {
            throw new NumberFormatException(
                "Hex string exceeds maximum length of 16 characters: " + cleanHex.length());
        }

        try {
            return cleanHex.chars().mapToLong(ch -> {
                int digit = Character.digit(ch, 16);
                if (digit < 0) {
                    throw new NumberFormatException(
                        "Invalid hex character in string: " + cleanHex);
                }
                return digit;
            }).reduce(0L, (result, digit) -> (result << 4) | digit);
        } catch (IllegalArgumentException e) {
            throw new NumberFormatException("Invalid hex character in string: " + cleanHex);
        }
    }

    /**
     * Converts a hexadecimal string to an integer using two's complement representation.
     * Unlike {@link Integer#parseInt(String, int)}, this method interprets the input as two's
     * complement, making it compatible with values generated by
     * {@link Integer#toHexString(int)}.
     *
     * <p><strong>Example:</strong><br>
     * {@code hexToInt("FF") returns 255}<br> {@code hexToInt("FFFFFFFF") returns -1}
     *
     * @param hex the hexadecimal string to convert. Can contain uppercase or lowercase letters
     *            [a-fA-F] and digits [0-9]. Must not exceed 16 characters after trimming
     *            whitespace.
     *
     * @return the integer value represented by the hexadecimal string
     *
     * @throws NumberFormatException if the input string is empty, exceeds 16 characters, or
     *                               contains invalid hexadecimal characters (valid:
     *                               [0-9a-fA-F])
     * @see Integer#toHexString(int)
     * @see Character#digit(char, int)
     * @since 1.0
     */
    public static int hexToInt(String hex) throws NumberFormatException {
        String cleanHex = hex.trim();

        if (cleanHex.isEmpty()) {
            throw new NumberFormatException("Hex string cannot be empty");
        }

        if (cleanHex.length() > 16) {
            throw new NumberFormatException("Hex string cannot be longer than 16 characters");
        }

        return cleanHex.chars().map(ch -> {
            int digit = Character.digit(ch, 16);
            if (digit < 0) {
                throw new NumberFormatException("Invalid hex character: " + (char) ch);
            }
            return digit;
        }).reduce(0, (result, digit) -> (result << 4) | digit);
    }

    /**
     * Converts a string to a boolean value using case-insensitive comparison.
     *
     * @param s   The string to convert
     * @param def The default value if the string can't be parsed. If default is true, returns
     *            false only if string equals "false" (case-insensitive). If default is false,
     *            returns true only if string equals "true" (case-insensitive).
     *
     * @return the boolean value or the default value if the string couldn't be parsed
     */
    public static boolean stringToBool(@Nullable String s, boolean def) {
        return switch (String.valueOf(s).toLowerCase()) {
            case "true" -> true;
            case "false" -> false;
            default -> def;
        };
    }

    /**
     * Find the boolean value of the field. Throw if the string is neither "yes"/"true" nor
     * "no"/"false".
     *
     * @param s the input string to convert
     *
     * @return the boolean value represented by the string
     *
     * @throws NumberFormatException if the input is null or not a valid boolean
     *                               representation
     */
    public static boolean stringToBool(String s) throws NumberFormatException {
        return switch (s) {
            case null -> throw new NumberFormatException("""
                                                         Null input is not allowed.
                                                         Please provide a valid boolean string representation.
                                                         """);
            case String str when str.equalsIgnoreCase("false") || str.equalsIgnoreCase("no") ->
                false;
            case String str when str.equalsIgnoreCase("true") || str.equalsIgnoreCase("yes") ->
                true;
            default -> throw new NumberFormatException("""
                                                       Invalid boolean: %s
                                                       Accepted values are: "true", "false", "yes", "no" (case-insensitive)
                                                       """.formatted(s));
        };
    }

    /**
     * Converts a boolean to a String of either "true" or "false".
     *
     * @param b the boolean value to convert.
     *
     * @return A "true" or "false" String.
     */
    public static String boolToString(boolean b) {
        return b ? "true" : "false";
    }

    /**
     * Splits a comma-separated string into an array of trimmed strings. This method processes
     * a string containing values separated by commas and returns an array where each element
     * is a trimmed substring.
     *
     * <p>The method handles the following cases:</p>
     * <ul>
     *     <li>Null input returns null</li>
     *     <li>Empty string returns empty array</li>
     *     <li>Whitespace around values is removed</li>
     *     <li>Empty elements between commas are preserved as empty strings</li>
     * </ul>
     *
     * <p><strong>Example usage:</strong></p>
     * <pre>
     *     String[] result1 = commaList("a,b,c");    // returns ["a", "b", "c"]
     *     String[] result2 = commaList(" a , b ");   // returns ["a", "b"]
     *     String[] result3 = commaList("");          // returns []
     *     String[] result4 = commaList(null);        // returns null
     *     String[] result5 = commaList("a,,c");      // returns ["a", "", "c"]
     * </pre>
     *
     * @param ls the input string containing comma-separated values. Can be null or empty.
     *
     * @return an array of strings where each element is a trimmed substring from the input, or
     * null if * the input is null. Returns an empty array for an empty input string.
     */
    public static String @Nullable [] commaList(@Nullable String ls) {
        if (ls == null) {
            return null;
        }
        return ls.isEmpty() ? new String[0] :
            Pattern.compile(",").splitAsStream(ls).map(String::trim).toArray(String[]::new);
    }

    /**
     * Creates a comma-separated string from an array of strings. This is a convenience method
     * equivalent to {@code textList(ls, ',')}.
     *
     * @param ls the array of strings to join
     *
     * @return a string containing all elements joined with commas
     *
     * @see #textList(String[], char)
     */
    public static String commaList(String[] ls) {
        return textList(ls, ',');
    }

    /**
     * Joins an array of strings using the specified delimiter character.
     * <p>
     * This method combines all elements from the input array into a single string, with the
     * specified delimiter character between elements. Null elements in the array are treated
     * as empty strings.
     * </p>
     *
     * <p>Example usage:</p>
     * <pre>
     * String[] arr = {"a", "b", "c"};
     * String result = textList(arr, ','); // Returns "a,b,c"
     * </pre>
     *
     * @param ls the array of strings to join
     * @param ch the delimiter character to use between elements
     *
     * @return a string containing all elements joined with the delimiter
     */
    public static String textList(@Nullable String[] ls, char ch) {
        if (ls.length == 0) {
            return "";
        }
        // Convert char to string for String.join()
        String delimiter = String.valueOf(ch);

        // Map null elements to empty strings and join
        return Arrays.stream(ls).map(s -> s == null ? "" : s)
                     .collect(Collectors.joining(delimiter));
    }

    /**
     * Creates a comma-separated string from an array of objects using ',' as the default
     * separator. This is a convenience method that calls {@link #commaList(Object[], char)}
     * with ',' as the separator.
     *
     * @param objects the array of objects to be joined
     *
     * @return a string containing all elements joined with commas, or an empty string if the
     * array is null or empty
     *
     * @see #commaList(Object[], char)
     */
    public static String commaList(Object[] objects) {
        return commaList(objects, ',');
    }

    /**
     * Creates a string by joining array elements with the specified separator character. Null
     * elements in the array are treated as empty strings.
     *
     * @param objects   the array of objects to be joined
     * @param separator the character to use as separator between elements
     *
     * @return a string containing all elements joined with the specified separator, or an
     * empty string if the array is null or empty
     *
     * @throws IllegalArgumentException if the separator is a control character
     */
    public static String commaList(Object @Nullable [] objects, char separator) {
        // Handle null or empty array
        if (objects == null || objects.length == 0) {
            return "";
        }

        // Validate separator
        if (Character.isISOControl(separator)) {
            throw new IllegalArgumentException("Separator cannot be a control character");
        }

        // Estimate capacity to avoid resizing
        int estimatedCapacity = Math.max(16, objects.length * 8);
        StringBuilder sb = new StringBuilder(estimatedCapacity);

        // Join elements
        boolean first = true;
        for (Object obj : objects) {
            if (!first) {
                sb.append(separator);
            }
            sb.append(obj == null ? "" : obj);
            first = false;
        }

        return sb.toString();
    }

    /**
     * Compares two byte arrays lexicographically, treating bytes as unsigned values.
     *
     * @param firstArray  the first byte array to compare
     * @param secondArray the second byte array to compare
     *
     * @return a negative integer, zero, or a positive integer as the first array is less than,
     * equal to, or greater than the second array
     *
     * @apiNote This method treats byte values as unsigned when comparing. For example, byte -1
     * is treated as 255 when comparing.
     * @implNote The comparison is done byte by byte, considering the unsigned value of each
     * byte. If arrays have different lengths, the shorter array is considered less than the
     * longer array if all bytes up to the shorter length are equal.
     * @see java.util.Arrays#compare(byte[], byte[])
     */
    public static int compareBytes(byte[] firstArray, byte[] secondArray) {
        // Get the minimum length between the two arrays
        int minLength = Math.min(firstArray.length, secondArray.length);

        // Compare byte by byte up to the minimum length
        for (int i = 0; i < minLength; ++i) {
            int byte1 = firstArray[i] & 0xff;
            int byte2 = secondArray[i] & 0xff;

            if (byte1 != byte2) {
                return Integer.compare(byte1, byte2);
            }
        }

        // If we get here, all bytes up to minLength are equal
        // Compare array lengths to determine result
        return Integer.compare(firstArray.length, secondArray.length);
    }

    /**
     * Compares two byte arrays for equality within specified ranges. This method performs a
     * byte-by-byte comparison and returns as soon as a mismatch is found. Note: This method is
     * not time-constant and may not be suitable for security-sensitive comparisons where
     * timing attacks are a concern.
     *
     * @param a    the first byte array to compare
     * @param b    the second byte array to compare
     * @param aoff the starting offset in the first array
     * @param boff the starting offset in the second array
     * @param len  the number of bytes to compare
     *
     * @return {@code true} if both arrays contain the same bytes in the specified ranges,
     * {@code false} otherwise
     *
     * @throws IllegalArgumentException if any of the following conditions are true:
     *                                  <ul>
     *                                  <li>offset or length values are negative</li>
     *                                  <li>offset + length would cause integer overflow</li>
     *                                  <li>offset + length exceeds array bounds</li>
     *                                  </ul>
     * @see java.security.MessageDigest#isEqual(byte[], byte[]) for timing-attack resistant
     * comparison
     */
    public static boolean byteArrayEqual(byte[] a, byte[] b, int aoff, int boff, int len) {
        // Validate input parameters
        if (aoff < 0 || boff < 0 || len < 0) {
            throw new IllegalArgumentException("Offset and length must be non-negative");
        }

        // Check for integer overflow
        if (len > 0 && (Integer.MAX_VALUE - len < aoff || Integer.MAX_VALUE - len < boff)) {
            throw new IllegalArgumentException("offset + length would cause integer overflow");
        }

        // Check array bounds
        if (a.length < aoff + len || b.length < boff + len) {
            return false;
        }

        // Perform byte-by-byte comparison
        for (int i = 0; i < len; i++) {
            if (a[i + aoff] != b[i + boff]) {
                return false;
            }
        }
        return true;
    }

    /**
     * Calculates a hash code for the entire byte array. This is a convenience method that
     * calls {@link #hashCode(byte[], int, int)} with the full array length.
     *
     * @param bytes the byte array to hash, must not be null
     *
     * @return the calculated hash code
     *
     * @see #hashCode(byte[], int, int)
     */
    public static int hashCode(byte[] bytes) {
        return hashCode(bytes, 0, bytes.length);
    }

    /**
     * Calculates a hash code for a portion of a byte array. This implementation is
     * particularly suited for byte arrays that contain random or pseudo-random data. The
     * algorithm processes bytes in reverse order and applies position-dependent bit shifting
     * to achieve better distribution of hash values.
     *
     * @param bytes  the byte array to hash, must not be null
     * @param offset the starting position in the array
     * @param length the number of bytes to include in the hash calculation
     *
     * @return the calculated hash code
     *
     * @throws IllegalArgumentException  if offset or length are negative
     * @throws IndexOutOfBoundsException if offset + length exceeds array bounds
     */
    public static int hashCode(byte[] bytes, int offset, int length) {
        if (offset < 0) {
            throw new IllegalArgumentException("Offset cannot be negative");
        }
        if (length < 0) {
            throw new IllegalArgumentException("Length cannot be negative");
        }
        if (offset + length > bytes.length) {
            throw new IndexOutOfBoundsException("Offset + length exceeds array bounds");
        }

        int hash = 0;
        for (int i = length - 1; i >= 0; --i) {
            int value = bytes[offset + i] & 0xff;
            hash ^= value << ((i & 3) << 3);
        }
        return hash;
    }

    /**
     * Computes a 64-bit hash value for the specified byte array.
     * <p>
     * This is a non-cryptographic hash function primarily designed for general-purpose
     * hashing. It should not be used for security-critical applications or where cryptographic
     * properties are required.
     * </p>
     *
     * @param bytes the byte array to hash
     *
     * @return a 64-bit hash value for the input array
     *
     * @see #longHashCode(byte[], int, int)
     */
    public static long longHashCode(byte[] bytes) {
        return longHashCode(bytes, 0, bytes.length);
    }

    /**
     * Computes a 64-bit hash value for a portion of the specified byte array.
     * <p>
     * This is a non-cryptographic hash function that processes bytes in reverse order,
     * applying bitwise operations to generate the hash value. Each byte contributes to the
     * final hash by being shifted left by a varying amount (0 to 56 bits) based on its
     * position.
     * </p>
     *
     * @param bytes  the byte array to hash
     * @param offset the starting position in the array
     * @param length the number of bytes to include in the hash computation
     *
     * @return a 64-bit hash value for the specified portion of the input array
     *
     * @throws IllegalArgumentException if offset or length are negative, or if offset + length
     *                                  is greater than the array length
     * @since 1.0
     */
    public static long longHashCode(byte[] bytes, int offset, int length) {
        if (offset < 0) {
            throw new IllegalArgumentException("Offset cannot be negative");
        }
        if (length < 0) {
            throw new IllegalArgumentException("Length cannot be negative");
        }
        if (offset + length > bytes.length) {
            throw new IllegalArgumentException("Offset + length exceeds array bounds");
        }

        long hashValue = 0;
        for (int position = length - 1; position >= 0; --position) {
            int byteValue = bytes[position + offset] & 0xff;
            int shiftAmount = (position & 7) << 3; // Multiply by 8
            hashValue ^= ((long) byteValue) << shiftAmount;
        }
        return hashValue;
    }

    /**
     * Converts an array of long integers to an array of bytes using little-endian byte
     * ordering. Each long value (64 bits) is converted into 8 bytes.
     *
     * @param longs the array of long integers to convert. Must not be null.
     *
     * @return a byte array containing the converted values in little-endian order
     *
     * @throws IllegalArgumentException if the input array length would cause integer overflow
     * @see java.nio.ByteBuffer
     * @see java.nio.ByteOrder
     * @since 1.0
     */
    public static byte[] longsToBytes(long[] longs) {
        // Check for potential integer overflow
        if (longs.length > Integer.MAX_VALUE / 8) {
            throw new IllegalArgumentException(
                "Input array too large: length would cause integer overflow");
        }

        // Use ByteBuffer for better performance
        ByteBuffer buffer =
            ByteBuffer.allocate(longs.length * 8).order(ByteOrder.LITTLE_ENDIAN);

        // Put all longs into the buffer
        buffer.asLongBuffer().put(longs);

        return buffer.array();
    }

    /**
     * Converts an array of bytes to an array of longs. This method processes the entire byte
     * array assuming little-endian byte order.
     *
     * @param buf the byte array to convert
     *
     * @return an array of longs containing the converted values
     *
     * @throws IllegalArgumentException if the buffer length is not a multiple of 8
     * @see #bytesToLongs(byte[], int, int)
     * @since 1.0
     */
    public static long[] bytesToLongs(byte[] buf) {
        return bytesToLongs(buf, 0, buf.length);
    }

    /**
     * Converts a portion of a byte array to an array of longs using little-endian byte order.
     * Each long value requires 8 bytes of input data. In little-endian order, the least
     * significant byte is stored at the lowest memory address.
     *
     * @param buf    the source byte array to convert
     * @param offset the starting position in the byte array
     * @param length the number of bytes to process (must be a multiple of 8)
     *
     * @return an array of longs containing the converted values
     *
     * @throws IllegalArgumentException  if the length is not a multiple of 8 or if the offset
     *                                   and length parameters specify an invalid range
     * @throws IndexOutOfBoundsException if the specified range is not within the buffer
     *                                   bounds
     * @since 1.0
     */
    public static long[] bytesToLongs(byte[] buf, int offset, int length) {
        if (length % 8 != 0) {
            throw new IllegalArgumentException("Length must be a multiple of 8");
        }
        if (offset < 0 || length < 0 || offset + length > buf.length) {
            throw new IndexOutOfBoundsException("Invalid offset or length parameters");
        }

        long[] longs = new long[length / 8];

        // Use ByteBuffer for better performance
        ByteBuffer buffer =
            ByteBuffer.wrap(buf, offset, length).order(ByteOrder.LITTLE_ENDIAN);

        for (int i = 0; i < longs.length; i++) {
            longs[i] = buffer.getLong();
        }

        return longs;
    }

    /**
     * Converts an array of bytes to a single long value using little-endian byte order. This
     * is a convenience method that calls {@link #bytesToLong(byte[], int)} with offset 0.
     *
     * @param bytes the byte array to convert
     *
     * @return the long value represented by the byte array
     *
     * @throws IllegalArgumentException if the byte array length is less than 8
     * @see #bytesToLong(byte[], int)
     */
    public static long bytesToLong(byte[] bytes) {
        return bytesToLong(bytes, 0);
    }

    /**
     * Converts an array of bytes to a single long value using little-endian byte order. The
     * conversion starts at the specified offset in the byte array.
     *
     * <p>The method expects 8 bytes to be available starting from the offset position,
     * as a long value consists of 8 bytes. The bytes are processed in little-endian order (the
     * least significant byte first).</p>
     *
     * <p>Example:</p>
     * <pre>
     * byte[] bytes = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};
     * long value = bytesToLong(bytes, 0);
     * // Results in: 0x0807060504030201L
     * // Where:
     * // bytes[0] = 0x01 (least significant byte)
     * // bytes[7] = 0x08 (most significant byte)
     * </pre>
     *
     * @param bytes  the byte array to convert
     * @param offset the starting position in the byte array
     *
     * @return the long value represented by the byte array starting at the offset
     *
     * @throws IllegalArgumentException if the byte array length is less than (offset + 8) or
     *                                  if the offset is negative
     */
    public static long bytesToLong(byte[] bytes, int offset) {
        if (offset < 0) {
            throw new IllegalArgumentException("Offset cannot be negative: " + offset);
        }

        final int REQUIRED_BYTES = 8;
        if (bytes.length < REQUIRED_BYTES + offset) {
            throw new IllegalArgumentException(
                String.format("Insufficient bytes available: required=%d, available=%d",
                              REQUIRED_BYTES + offset, bytes.length));
        }

        return ByteBuffer.wrap(bytes, offset, REQUIRED_BYTES).order(ByteOrder.LITTLE_ENDIAN)
                         .getLong();
    }

    /**
     * Converts a byte array to an integer value using little-endian byte order. This is a
     * convenience method that calls {@link #bytesToInt(byte[], int)} with offset 0.
     *
     * @param bytes the byte array to convert (must contain at least 4 bytes)
     *
     * @return the integer value represented by the first 4 bytes of the array
     *
     * @throws IllegalArgumentException if the byte array is null or contains fewer than 4
     *                                  bytes
     * @see #bytesToInt(byte[], int)
     */
    public static int bytesToInt(byte[] bytes) {
        return bytesToInt(bytes, 0);
    }

    /**
     * Converts a byte array to an integer value using little-endian byte order, starting from
     * the specified offset position.
     *
     * <p>The method reads 4 consecutive bytes from the array, starting at the specified
     * offset, and combines them into a single integer value. The bytes are interpreted in
     * little-endian order (the least significant byte first).
     *
     * <p>Example usage:
     * <pre>{@code
     * byte[] bytes = {0x2A, 0x00, 0x00, 0x00};
     * int value = bytesToInt(bytes, 0); // Returns 42
     *
     * // Another example showing byte order:
     * byte[] bytes2 = {0x01, 0x02, 0x03, 0x04};
     * int value2 = bytesToInt(bytes2, 0); // Returns 0x04030201
     * }</pre>
     *
     * @param bytes  the byte array containing the bytes to convert
     * @param offset the starting position in the array (must be non-negative and leave at
     *               least 4 bytes from this position to the end of the array)
     *
     * @return the integer value represented by the 4 bytes starting at the offset position
     *
     * @throws IllegalArgumentException  if the byte array is null, or if there are fewer than
     *                                   4 bytes available from the offset position
     * @throws IndexOutOfBoundsException if the offset is negative or would cause array bounds
     *                                   overflow
     */
    public static int bytesToInt(byte[] bytes, int offset) {
        if (offset < 0) {
            throw new IndexOutOfBoundsException("Offset cannot be negative: " + offset);
        }

        final int REQUIRED_BYTES = 4;
        if (bytes.length - offset < REQUIRED_BYTES) {
            throw new IllegalArgumentException(
                String.format("Insufficient bytes available: required=%d, available=%d",
                              REQUIRED_BYTES + offset, bytes.length));
        }

        return ByteBuffer.wrap(bytes, offset, REQUIRED_BYTES).order(ByteOrder.LITTLE_ENDIAN)
                         .getInt();
    }

    /**
     * Converts an array of bytes to a short integer using little-endian byte order.
     *
     * @param buf    the byte array to convert from (must not be null and have length >= 2)
     * @param offset the starting position in the array (must be non-negative)
     *
     * @return the short value represented by two bytes starting at the specified offset
     *
     * @throws IllegalArgumentException if the buffer is too small or offset is invalid
     */
    public static short bytesToShort(byte[] buf, int offset) {
        if (buf.length < 2 || offset < 0 || offset > buf.length - 2) {
            throw new IllegalArgumentException("Invalid buffer length or offset");
        }

        return (short) ((buf[offset + 1] & 0xFF) << 8 | (buf[offset] & 0xFF));
    }

    /**
     * Converts an array of bytes to an array of integers using little-endian byte order. Each
     * integer requires 4 bytes of input data.
     *
     * @param buf    the byte array to convert (must not be null)
     * @param offset the starting position in the byte array (must be non-negative)
     * @param length the number of bytes to process (must be a multiple of 4)
     *
     * @return an array of integers containing the converted values
     *
     * @throws IllegalArgumentException if length is not a multiple of 4 or if offset/length
     *                                  combination is invalid
     */
    public static int[] bytesToInts(byte[] buf, int offset, int length) {
        if (length % Integer.BYTES != 0) {
            throw new IllegalArgumentException("Length must be a multiple of 4");
        }
        if (offset < 0 || length < 0 || offset + length > buf.length) {
            throw new IllegalArgumentException("Invalid offset or length");
        }

        int[] ints = new int[length / Integer.BYTES];
        ByteBuffer buffer =
            ByteBuffer.wrap(buf, offset, length).order(ByteOrder.LITTLE_ENDIAN);

        for (int i = 0; i < ints.length; i++) {
            ints[i] = buffer.getInt();
        }
        return ints;
    }

    /**
     * Converts an entire byte array to an array of integers using little-endian byte order.
     * The byte array length must be a multiple of 4.
     *
     * @param buf the byte array to convert (must not be null)
     *
     * @return an array of integers containing the converted values
     *
     * @throws IllegalArgumentException if the input array length is not a multiple of 4
     */
    public static int[] bytesToInts(byte[] buf) {
        return bytesToInts(buf, 0, buf.length);
    }

    /**
     * Converts a long value to an array of 8 bytes using little-endian byte order.
     *
     * @param value the long value to convert
     *
     * @return a byte array of length 8 containing the converted value
     */
    public static byte[] longToBytes(long value) {
        return ByteBuffer.allocate(Long.BYTES).order(ByteOrder.LITTLE_ENDIAN).putLong(value)
                         .array();
    }

    // TODO
    //    /* Removes up to one "(bits) per second" qualifier at the end of the string. If
    //    present
    //    such a
    //    qualifier will
    //     * prevent parsing as a size.
    //     * @see freenet.support.Fields#parseInt(String)
    //     */
    //    public static String trimPerSecond(String limit) {
    //        limit = limit.trim();
    //        if (limit.isEmpty()) {
    //            return "";
    //        }
    //        /*
    //         * IEC endings are case sensitive, so the input string's case should not be
    //         modified.
    //         However,
    //         *  the
    //         * qualifiers should not be case sensitive.
    //         */
    //        final String lower = limit.toLowerCase();
    //        for (String ending : new String[]{"/s", "/sec", "/second", "ps",
    //            NodeL10n.getBase().getString("FirstTimeWizardToadlet.bandwidthPerSecond")
    //            .toLowerCase()}) {
    //            if (lower.endsWith(ending)) {
    //                return limit.substring(0, limit.length() - ending.length());
    //            }
    //        }
    //        return limit;
    //    }
    //
    //    public static int parseInt(String s, Dimension dimension) throws
    //    NumberFormatException {
    //        switch (dimension) {
    //            case NOT:
    //            case SIZE:
    //                return parseInt(s);
    //            case DURATION:
    //                long durationInMillis = TimeUtil.toMillis(s);
    //                if ((int) durationInMillis == durationInMillis) {
    //                    return (int) durationInMillis;
    //                }
    //                throw new ArithmeticException("integer overflow");
    //        }
    //        throw new AssertionError("Unknown dimension " + dimension);
    //    }

    /**
     * Converts an array of integers to bytes using little-endian byte order.
     *
     * @param ints the integer array to convert
     *
     * @return a byte array containing the converted integers
     */
    public static byte[] intsToBytes(int[] ints) {
        return intsToBytes(ints, 0, ints.length);
    }

    /**
     * Converts a portion of an integer array to bytes using little-endian byte order.
     *
     * @param ints   the integer array to convert (must not be null)
     * @param offset the starting position in the array (must be non-negative)
     * @param length the number of integers to convert (must be non-negative)
     *
     * @return a byte array containing the converted integers
     *
     * @throws IllegalArgumentException if offset or length are invalid
     */
    public static byte[] intsToBytes(int[] ints, int offset, int length) {
        if (offset < 0 || length < 0 || offset + length > ints.length) {
            throw new IllegalArgumentException("Invalid offset or length");
        }

        ByteBuffer buffer =
            ByteBuffer.allocate(length * Integer.BYTES).order(ByteOrder.LITTLE_ENDIAN);
        for (int i = 0; i < length; i++) {
            buffer.putInt(ints[i + offset]);
        }
        return buffer.array();
    }

    /**
     * Converts a single integer to bytes using little-endian byte order.
     *
     * @param value the integer to convert
     *
     * @return a byte array of length 4 containing the converted integer
     */
    public static byte[] intToBytes(int value) {
        return ByteBuffer.allocate(Integer.BYTES).order(ByteOrder.LITTLE_ENDIAN).putInt(value)
                         .array();
    }

    // TODO
    //    public static String intToString(int val, Dimension dimension) {
    //        switch (dimension) {
    //            case NOT:
    //                return intToString(val, false);
    //            case SIZE:
    //                return intToString(val, true);
    //            case DURATION:
    //                return TimeUtil.formatTime(val, 6, false);
    //        }
    //        throw new AssertionError("Unknown dimension " + dimension);
    //    }

    /**
     * Converts a short value to an array of bytes using little-endian byte order. The returned
     * array will always have a length of 2 bytes.
     *
     * @param value the short value to convert
     *
     * @return a byte array of length 2 containing the converted value
     */
    public static byte[] shortToBytes(short value) {
        return ByteBuffer.allocate(Short.BYTES).order(ByteOrder.LITTLE_ENDIAN).putShort(value)
                         .array();
    }

    /**
     * Parses a human-readable string representation of a number with optional SI (metric) or
     * IEC (binary) units into a short value.
     *
     * <p>This method supports both SI prefixes and IEC binary prefixes up to Exa/Ei.
     * The input string may optionally end with 'B' or 'iB' which will be ignored. The
     * multiplier characters are case-sensitive where 'k' represents 1000 and 'K' represents
     * 1024.</p>
     *
     * @param s the string to parse, must not be null
     *
     * @return the parsed value as a short
     *
     * @throws NumberFormatException if the string cannot be parsed or the result exceeds
     *                               Short.MAX_VALUE
     */
    public static short parseShort(String s) throws NumberFormatException {
        try {
            double value = parseWithMultiplier(s);
            if (value > Short.MAX_VALUE || value < Short.MIN_VALUE) {
                throw new NumberFormatException("Value out of range for short: " + value);
            }
            return (short) value;
        } catch (NumberFormatException e) {
            throw e;
        } catch (Exception e) {
            throw new NumberFormatException("Failed to parse value: " + e.getMessage());
        }
    }

    /**
     * Parses a human-readable string representation of a number with optional SI (metric) or
     * IEC (binary) units into an int value.
     *
     * <p>This method supports both SI prefixes and IEC binary prefixes up to Exa/Ei.
     * The input string may optionally end with 'B' or 'iB' which will be ignored. The
     * multiplier characters are case-sensitive where 'k' represents 1000 and 'K' represents
     * 1024.</p>
     *
     * @param s the string to parse, must not be null
     *
     * @return the parsed value as an int
     *
     * @throws NumberFormatException if the string cannot be parsed or the result exceeds
     *                               Integer.MAX_VALUE
     */
    public static int parseInt(String s) throws NumberFormatException {
        try {
            double value = parseWithMultiplier(s);
            if (value > Integer.MAX_VALUE || value < Integer.MIN_VALUE) {
                throw new NumberFormatException("Value out of range for int: " + value);
            }
            return (int) value;
        } catch (NumberFormatException e) {
            throw e;
        } catch (Exception e) {
            throw new NumberFormatException("Failed to parse value: " + e.getMessage());
        }
    }

    /**
     * Parses a human-readable string representation of a number with optional SI (metric) or
     * IEC (binary) units into a long value.
     *
     * <p>This method supports both SI prefixes and IEC binary prefixes up to Exa/Ei.
     * The input string may optionally end with 'B' or 'iB' which will be ignored. The
     * multiplier characters are case-sensitive where 'k' represents 1000 and 'K' represents
     * 1024.</p>
     *
     * @param s the string to parse, must not be null
     *
     * @return the parsed value as a long
     *
     * @throws NumberFormatException if the string cannot be parsed or the result exceeds
     *                               Long.MAX_VALUE
     */
    public static long parseLong(String s) throws NumberFormatException {
        try {
            double value = parseWithMultiplier(s);
            if (value > Long.MAX_VALUE || value < Long.MIN_VALUE) {
                throw new NumberFormatException("Value out of range for long: " + value);
            }
            return (long) value;
        } catch (NumberFormatException e) {
            throw e;
        } catch (Exception e) {
            throw new NumberFormatException("Failed to parse value: " + e.getMessage());
        }
    }

    /**
     * Converts numeric values to their string representation, optionally with size units.
     *
     * @param <T>    The numeric type extending Number
     * @param value  The numeric value to convert
     * @param isSize If true, allows all unit multiples; if false, only uses powers of 1000
     *
     * @return A string representation of the value, potentially with size units
     *
     * @throws IllegalArgumentException if the input type is not supported
     * @apiNote This method supports the following size units:
     * <ul>
     *   <li>Decimal units (K, M, G, etc.) for powers of 1000</li>
     *   <li>Binary units (KiB, MiB, GiB, etc.) for powers of 1024</li>
     * </ul>
     */
    public static <T extends Number> String numberToString(T value, boolean isSize) {
        // Convert the input value to long for consistent processing
        long val = switch (value) {
            case Long l -> l;
            case Integer i -> i;
            case Short s -> s;
            default -> throw new IllegalArgumentException(
                "Unsupported number type: " + value.getClass());
        };

        return formatWithUnits(val, isSize);
    }

    /**
     * Converts a long value to its string representation, optionally with size units.
     *
     * @param val    The long value to convert
     * @param isSize If true, allows all unit multiples; if false, only uses powers of 1000
     *
     * @return A string representation of the value, potentially with size units
     *
     * @apiNote This method supports the following size units:
     * <ul>
     *   <li>Decimal units (K, M, G, etc.) for powers of 1000</li>
     *   <li>Binary units (KiB, MiB, GiB, etc.) for powers of 1024</li>
     * </ul>
     * @deprecated Use {@link #numberToString(Number, boolean)} instead
     */
    public static String longToString(long val, boolean isSize) {
        return formatWithUnits(val, isSize);
    }

    /**
     * Converts an integer value to its string representation, optionally with size units.
     *
     * @param val    The integer value to convert
     * @param isSize If true, allows all unit multiples; if false, only uses powers of 1000
     *
     * @return A string representation of the value, potentially with size units
     *
     * @apiNote This method supports the following size units:
     * <ul>
     *   <li>Decimal units (K, M, G, etc.) for powers of 1000</li>
     *   <li>Binary units (KiB, MiB, GiB, etc.) for powers of 1024</li>
     * </ul>
     * @deprecated Use {@link #numberToString(Number, boolean)} instead
     */
    public static String intToString(int val, boolean isSize) {
        return formatWithUnits(val, isSize);
    }

    /**
     * Converts a short value to its string representation, optionally with size units.
     *
     * @param val    The short value to convert
     * @param isSize If true, allows all unit multiples; if false, only uses powers of 1000
     *
     * @return A string representation of the value, potentially with size units
     *
     * @apiNote This method supports the following size units:
     * <ul>
     *   <li>Decimal units (K, M, G, etc.) for powers of 1000</li>
     *   <li>Binary units (KiB, MiB, GiB, etc.) for powers of 1024</li>
     * </ul>
     * @deprecated Use {@link #numberToString(Number, boolean)} instead
     */
    public static String shortToString(short val, boolean isSize) {
        return formatWithUnits(val, isSize);
    }

    /**
     * Converts a portion of a byte array to an array of double values.
     *
     * @param data   the byte array to convert from
     * @param offset the starting position in the byte array
     * @param length the number of bytes to convert
     *
     * @return an array of doubles converted from the specified portion of the byte array
     *
     * @throws IllegalArgumentException if offset or length are negative, or if they specify a
     *                                  range that goes beyond the bounds of the input array
     * @throws IllegalArgumentException if the length is not a multiple of 8 (bytes per
     *                                  double)
     */
    public static double[] bytesToDoubles(byte[] data, int offset, int length) {
        if (offset < 0 || length < 0 || offset + length > data.length) {
            throw new IllegalArgumentException("Invalid offset or length");
        }
        if (length % 8 != 0) {
            throw new IllegalArgumentException("Length must be a multiple of 8");
        }

        long[] longs = bytesToLongs(data, offset, length);
        return Arrays.stream(longs).mapToDouble(Double::longBitsToDouble).toArray();
    }

    /**
     * Converts an array of double values to a byte array.
     *
     * @param doubles the array of doubles to convert
     *
     * @return a byte array containing the binary representation of the doubles
     */
    public static byte[] doublesToBytes(double[] doubles) {
        long[] longs = Arrays.stream(doubles).mapToLong(Double::doubleToLongBits).toArray();
        return longsToBytes(longs);
    }

    /**
     * Converts an entire byte array to an array of double values. This is a convenience method
     * that calls {@link #bytesToDoubles(byte[], int, int)} with offset 0 and the length of the
     * entire array.
     *
     * @param data the byte array to convert
     *
     * @return an array of doubles converted from the byte array
     *
     * @throws IllegalArgumentException if the input array's length is not a multiple of 8
     */
    public static double[] bytesToDoubles(byte[] data) {
        return bytesToDoubles(data, 0, data.length);
    }

    /**
     * Removes empty lines and trims leading/trailing whitespace from each line in the given
     * string. Empty lines (containing only whitespace) are completely removed from the output.
     * Each remaining line is trimmed of leading and trailing whitespace.
     *
     * @param str the input string to be processed. If null, returns an empty string.
     *
     * @return a new string with empty lines removed and remaining lines trimmed. Each
     * non-empty line is terminated with line separator '\n'.
     *
     * @see String#trim()
     * @see System#lineSeparator()
     */
    public static String trimLines(String str) {
        if (str == null) {
            return "";
        }

        return str.lines().map(String::trim).filter(line -> !line.isEmpty())
                  .collect(StringBuilder::new, (sb, line) -> sb.append(line).append('\n'),
                           StringBuilder::append).toString();
    }

    /**
     * Compares two version strings.
     *
     * <p>
     * The comparison algorithm alternates between comparing numeric and non-numeric parts of
     * the version strings. Numeric parts are compared numerically, and non-numeric parts are
     * compared lexicographically. Numeric parts are considered greater than non-numeric parts.
     * Leading zeros in numeric parts are taken into account.
     * </p>
     *
     * @param x The first version string to compare.
     * @param y The second version string to compare.
     *
     * @return A negative integer, zero, or a positive integer as the first argument is less
     * than, equal to, or greater than the second.
     */
    public static int compareVersion(String x, String y) {
        int i = 0, j = 0;
        boolean wantDigits = false;

        while (i < x.length() || j < y.length()) {
            int xStart = i, yStart = j; // Store start indices of current segment

            // Extract digits or non-digits
            i += getDigits(x, i, wantDigits);
            j += getDigits(y, j, wantDigits);

            String xSegment = x.substring(xStart, i);
            String ySegment = y.substring(yStart, j);

            if (wantDigits) {
                //noinspection StatementWithEmptyBody
                if (xSegment.isEmpty() && ySegment.isEmpty()) {
                    // Both segments are empty, continue to the next part
                } else if (xSegment.isEmpty()) {
                    return -1; // Non-numeric is less than numeric
                } else if (ySegment.isEmpty()) {
                    return 1; // Numeric is greater than non-numeric
                } else {
                    try {
                        long a = Long.parseLong(xSegment);
                        long b = Long.parseLong(ySegment);
                        int result = Long.compare(a, b);
                        if (result != 0) {
                            return result;
                        }
                        // If numbers are equal, compare lengths to handle leading zeros
                        result = Integer.compare(xSegment.length(), ySegment.length());
                        if (result != 0) {
                            return -result; // Longer numeric string with same value is
                            // considered
                            // smaller (leading zeros)
                        }
                    } catch (NumberFormatException e) {
                        // Handle cases where numeric parts are too large for long
                        return xSegment.compareTo(ySegment);
                    }
                }
            } else {
                int result = xSegment.compareTo(ySegment);
                if (result != 0) {
                    return result;
                }
            }
            wantDigits = !wantDigits;
        }
        return 0; // Versions are equal
    }

    /**
     * Compares two objects based on their identity hash codes. This method provides a
     * consistent ordering for object references, which is useful for preventing deadlocks when
     * acquiring multiple locks.
     *
     * <p>The comparison is based on {@link System#identityHashCode(Object)},
     * which provides a stable hash code based on object identity rather than the object's
     * {@code hashCode()} implementation.</p>
     *
     * @param o1 the first object to compare
     * @param o2 the second object to compare
     *
     * @return a negative integer, zero, or a positive integer as the first argument is less
     * than, equal to, or greater than the second
     */
    public static int compareObjectID(Object o1, Object o2) {
        return Integer.compare(System.identityHashCode(o1), System.identityHashCode(o2));
    }

    /**
     * Compares two integer values, handling potential overflow issues.
     *
     * @param x The first integer.
     * @param y The second integer.
     *
     * @return 1 if x > y, -1 if x < y, 0 if x == y.
     */
    public static int compare(int x, int y) {
        return Integer.compare(x, y);
    }

    /**
     * Compares two long values, handling potential overflow issues.
     *
     * @param x The first long value.
     * @param y The second long value.
     *
     * @return 1 if x > y, -1 if x < y, 0 if x == y.
     */
    public static int compare(long x, long y) {
        return Long.compare(x, y);
    }

    /**
     * Compares two double values, handling NaN values correctly. NaN values are considered
     * less than any other value, and two NaNs are considered equal.
     *
     * @param x The first double value.
     * @param y The second double value.
     *
     * @return 1 if x > y, -1 if x < y, 0 if x == y.
     */
    public static int compare(double x, double y) {
        return Double.compare(x, y);
    }

    /**
     * Compares two float values, handling NaN values correctly. NaN values are considered less
     * than any other value, and two NaNs are considered equal.
     *
     * @param x The first float value.
     * @param y The second float value.
     *
     * @return 1 if x > y, -1 if x < y, 0 if x == y.
     */
    public static int compare(float x, float y) {
        return Float.compare(x, y);
    }

    /**
     * Compares two Date objects, handling null values gracefully. Null values are considered
     * less than any non-null Date.
     *
     * @param a The first Date object (may be null).
     * @param b The second Date object (may be null).
     *
     * @return A negative integer, zero, or a positive integer if a is less than, equal to, or
     * greater than b, respectively.
     *
     * @see Objects#compare(Object, Object, java.util.Comparator)
     */
    public static int compare(@Nullable Date a, @Nullable Date b) {
        return Objects.compare(a, b, Date::compareTo);
    }

    /**
     * Copies all the remaining bytes in the buffer to a new byte array.
     *
     * <p>This method reads all bytes from the current position of the buffer up to its limit
     * and copies them into a newly allocated byte array. After the copy operation, the
     * position of the input buffer will be advanced to its limit.</p>
     *
     * <p>Example usage:
     * <pre>{@code
     * ByteBuffer buffer = ByteBuffer.allocate(10);
     * buffer.put(new byte[]{1, 2, 3, 4, 5});
     * buffer.flip(); // Prepare for reading
     * byte[] byteArray = copyToArray(buffer); // byteArray will contain [1, 2, 3, 4, 5]
     * // buffer.position() will now be equal to buffer.limit()
     * }</pre></p>
     *
     * @param buf The input {@code ByteBuffer}. It must not be {@code null}.
     *
     * @return A new byte array containing the remaining bytes from the buffer. The size of the
     * array will be equal to {@code buf.remaining()} at the time of the call.
     *
     * @throws NullPointerException if the input buffer {@code buf} is {@code null}.
     * @since 1.0
     */
    public static byte[] copyToArray(ByteBuffer buf) {
        byte[] ret = new byte[buf.remaining()];
        buf.get(ret);
        return ret;
    }

    /**
     * Extracts the length of a sequence of digits or non-digits from a string.
     *
     * @param str        The string to extract from.
     * @param i          The starting index in the string.
     * @param wantDigits {@code true} if looking for digits, {@code false} if looking for
     *                   non-digits.
     *
     * @return The length of the sequence of digits or non-digits.
     */
    static int getDigits(String str, int i, boolean wantDigits) {
        int origI = i;
        for (; i < str.length(); i++) {
            if (Character.isDigit(str.charAt(i)) != wantDigits) {
                break;
            }
        }
        return i - origI;
    }

    /**
     * Converts a numeric value to a string representation with optional size units.
     *
     * @param value  The numeric value to convert
     * @param isSize If true, allows all unit multiples; if false, only uses powers of 1000
     *
     * @return A string representation of the value, potentially with size units
     *
     * @implNote This is a helper method that handles the core conversion logic
     */
    private static String formatWithUnits(long value, boolean isSize) {
        if (value <= 0) {
            return String.valueOf(value);
        }

        for (int i = MULTIPLES.length - 1; i >= 0; i--) {
            if (value > MULTIPLES[i] && value % MULTIPLES[i] == 0 &&
                (isSize || MULTIPLES[i] % 1000 == 0)) {

                String unit = MULTIPLES_2[i];
                boolean isBinaryUnit = !unit.equals(unit.toLowerCase());

                return value / MULTIPLES[i] + unit + (isBinaryUnit ? "iB" : "");
            }
        }

        return String.valueOf(value);
    }

    /**
     * Internal helper method to parse a string with multiplier suffixes.
     *
     * @param s the string to parse
     *
     * @return the parsed value as a double
     *
     * @throws NumberFormatException if the string cannot be parsed
     */
    private static double parseWithMultiplier(String s) throws NumberFormatException {
        // Remove trailing B or iB
        String normalized = s.strip().replaceFirst("(i)?B$", "");

        if (normalized.isEmpty()) {
            throw new NumberFormatException("Empty input after removing suffix");
        }

        try {
            long multiplier = 1L;
            int x = normalized.length() - 1;
            int idx;

            // Process multiplier characters from right to left
            while (x >= 0 && (idx = "kKmMgGtTeE".indexOf(normalized.charAt(x))) != -1) {
                x--;
                // Map the index to MULTIPLES array (even indices for SI, odd for binary)
                int multiplierIndex = idx / 2 * 2 + (idx % 2);
                multiplier = Math.multiplyExact(multiplier, MULTIPLES[multiplierIndex]);
            }

            // Parse the remaining numeric part
            return Double.parseDouble(normalized.substring(0, x + 1)) * multiplier;

        } catch (ArithmeticException e) {
            throw new NumberFormatException("Arithmetic overflow: " + e.getMessage());
        }
    }

}
